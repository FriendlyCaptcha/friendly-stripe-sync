// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: prices.sql

package postgres

import (
	"context"
	"database/sql"

	"github.com/tabbed/pqtype"
)

const deleteAllPrices = `-- name: DeleteAllPrices :exec
DELETE FROM "stripe"."prices"
`

func (q *Queries) DeleteAllPrices(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPrices)
	return err
}

const deletePrice = `-- name: DeletePrice :exec
DELETE FROM "stripe"."prices" WHERE id = $1
`

func (q *Queries) DeletePrice(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deletePrice, id)
	return err
}

const priceExists = `-- name: PriceExists :one
SELECT EXISTS (SELECT 1 FROM "stripe"."prices" WHERE id = $1)
`

func (q *Queries) PriceExists(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRowContext(ctx, priceExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const upsertPrice = `-- name: UpsertPrice :exec
INSERT INTO "stripe"."prices" (
    id, object, active, billing_scheme, created, currency, livemode, lookup_key, metadata,
    nickname, recurring, type, unit_amount, tiers_mode, transform_quantity, unit_amount_decimal,
    product, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, NOW()
) ON CONFLICT (id) DO UPDATE SET 
    object = EXCLUDED.object,
    active = EXCLUDED.active,
    billing_scheme = EXCLUDED.billing_scheme,
    created = EXCLUDED.created,
    currency = EXCLUDED.currency,
    livemode = EXCLUDED.livemode,
    lookup_key = EXCLUDED.lookup_key,
    metadata = EXCLUDED.metadata,
    nickname = EXCLUDED.nickname,
    recurring = EXCLUDED.recurring,
    type = EXCLUDED.type,
    unit_amount = EXCLUDED.unit_amount,
    tiers_mode = EXCLUDED.tiers_mode,
    transform_quantity = EXCLUDED.transform_quantity,
    unit_amount_decimal = EXCLUDED.unit_amount_decimal,
    product = EXCLUDED.product,
    updated_at = NOW()
`

type UpsertPriceParams struct {
	ID                string
	Object            string
	Active            bool
	BillingScheme     string
	Created           int64
	Currency          string
	Livemode          bool
	LookupKey         sql.NullString
	Metadata          pqtype.NullRawMessage
	Nickname          sql.NullString
	Recurring         pqtype.NullRawMessage
	Type              string
	UnitAmount        sql.NullInt64
	TiersMode         sql.NullString
	TransformQuantity pqtype.NullRawMessage
	UnitAmountDecimal sql.NullFloat64
	Product           string
}

func (q *Queries) UpsertPrice(ctx context.Context, arg UpsertPriceParams) error {
	_, err := q.db.ExecContext(ctx, upsertPrice,
		arg.ID,
		arg.Object,
		arg.Active,
		arg.BillingScheme,
		arg.Created,
		arg.Currency,
		arg.Livemode,
		arg.LookupKey,
		arg.Metadata,
		arg.Nickname,
		arg.Recurring,
		arg.Type,
		arg.UnitAmount,
		arg.TiersMode,
		arg.TransformQuantity,
		arg.UnitAmountDecimal,
		arg.Product,
	)
	return err
}
